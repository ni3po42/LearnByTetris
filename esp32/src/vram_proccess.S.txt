	.file	"vram_process.S"
	.text
	.global	GPIO_OUT_REG
	.data
	.align	4
	.type	GPIO_OUT_REG, @object
	.size	GPIO_OUT_REG, 4
GPIO_OUT_REG:
	.word	0x3FF44004
	.text
	.literal_position
	.literal .LC0, GPIO_OUT_REG
	.align	4
	.global	vram_process
	.type	vram_process, @function
vram_process:
	entry	sp, 64		// allocate stack frame, might not need to be as big anymore
	
	// a2 : vram address
	// a3 : GPIO_OUT_REG address
	// a7 : end vram address check


	l32r	a3, .LC0	// so, I 'think' this is looking up the address of GPIO_OUT_REG. The l32i.n call below gets the address at GPIO_OUT_REG
	memw				// wait until loaded	
	l32i.n	a3, a3, 0	// stores the GPIO_REG address into a3

	addi 	a7, a2, 80	// adds 159 to vram address to get end address for checking
	addi 	a7, a7, 79

	j		.L2			// goto loop bound check
	//
	//	Loop Begin
	//
.L3:		
	//s8i		a3, a2, 0	// store low value in vram[counter] (a3) into address of GPIOs (a2)	
	nop.n
	nop.n
	nop.n
	nop.n
	nop.n

	nop.n
	nop.n
	nop.n
	nop.n
	nop.n

	nop.n
	nop.n
	nop.n
	nop.n
	nop.n
	// s8i		a3, a2, 0	// store high value in vram[counter] (a3) into address of GPIOs (a2)	

	addi.n	a2, a2, 1	// increase vram address by 1
	//
	// Loop bound check
	//
.L2:	
	bgeu	a2, a3, .L3	// if a2 <= a3 (159)
	// might need to add some nop.n for alignment reasons	
	retw.n				// donezo
