	.file	"vram_process.S"
	.text
	.global	GPIO_OUT_REG
	.data
	.align	4
	.type	GPIO_OUT_REG, @object
	.size	GPIO_OUT_REG, 4
GPIO_OUT_REG:
	.word	0x3FF44004
	.text
	.literal_position
	.literal .LC0, GPIO_OUT_REG
	.align	4
	.global	vram_process
	.type	vram_process, @function
vram_process:
	entry	sp, 64		// allocate stack frame
	mov.n	a7, sp		// store stack pointer address in a7
	
	s32i.n	a2, a7, 16	// store vram address from parmater (a2) into stack frame
	movi.n	a2, 0		// initialize counter to 0 in a2
	s8i	a2, a7, 0		// store counter in address in a7
	j		.L2			// goto loop bound check
	//
	//	Loop Begin
	//
.L3:
	l8ui	a2, a7, 0	// load counter value from address in a7 into a2
	l32i.n	a3, a7, 16	// load vram address into a3
	add.n	a2, a3, a2	// offset vram address by number of bytes in a2
	l8ui	a3, a2, 0	// load vram[counter] value into a3
	l32r	a2, .LC0	// so, I 'think' this is looking up the address of GPIO_OUT_REG. The l32i.n call below gets the address at GPIO_OUT_REG
	memw				// wait until loaded
	//
	// we need to address into just pins 24-31, with 25,26,27 being the target GPIOs
	// 
	l32i.n	a2, a2, 0	// stores the GPIO_REG address into a2
	s8i		a3, a2, 0	// store value in vram[counter] (a3) into address of GPIOs (a2)
	l8ui	a2, a7, 0	// get counter from address in a7
	addi.n	a2, a2, 1	// increment counter by 1
	s8i		a2, a7, 0	// store counter in address at a7
	//
	// Loop bound check
	//
.L2:
	l8ui	a2, a7, 0	// load counter from address in a7 into a2
	movi	a3, 0x9f	// store 159 (end value of loop)
	bgeu	a3, a2, .L3	// if a2 <= a3 (159)
	nop.n
	nop.n
	retw.n				// donezo
